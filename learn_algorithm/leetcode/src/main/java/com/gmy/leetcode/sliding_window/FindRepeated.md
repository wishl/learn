由于
s 中只含有
4
4 种字符，我们可以将每个字符用
2
2 个比特表示，即：

A
A 表示为二进制
00
00；
C
C 表示为二进制
01
01；
G
G 表示为二进制
10
10；
T
T 表示为二进制
11
11。
如此一来，一个长为
10
10 的字符串就可以用
20
20 个比特表示，而一个
int
int 整数有
32
32 个比特，足够容纳该字符串，因此我们可以将
�
s 的每个长为
10
10 的子串用一个
int
int 整数表示（只用低
20
20 位）。

注意到上述字符串到整数的映射是一一映射，每个整数都对应着一个唯一的字符串，因此我们可以将方法一中的哈希表改为存储每个长为
10
10 的子串的整数表示。

如果我们对每个长为
10
10 的子串都单独计算其整数表示，那么时间复杂度仍然和方法一一样为 O(NL)。为了优化时间复杂度，我们可以用一个大小固定为
10
10 的滑动窗口来计算子串的整数表示。设当前滑动窗口对应的整数表示为
x，当我们要计算下一个子串时，就将滑动窗口向右移动一位，此时会有一个新的字符进入窗口，以及窗口最左边的字符离开窗口，这些操作对应的位运算，按计算顺序表示如下：

滑动窗口向右移动一位：x = x << 2，由于每个字符用
2
2 个比特表示，所以要左移
2
2 位；
一个新的字符
ch
ch 进入窗口：x = x | bin[ch]，这里
bin
[
ch
]
bin[ch] 为字符
ch
ch 的对应二进制；
窗口最左边的字符离开窗口：x = x & ((1 << 20) - 1)，由于我们只考虑
�
x 的低
20
20 位比特，需要将其余位置零，即与上 (1 << 20) - 1。
将这三步合并，就可以用
�
(
1
)
O(1) 的时间计算出下一个子串的整数表示，即 x = ((x << 2) | bin[ch]) & ((1 << 20) - 1)。

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/repeated-dna-sequences/solution/zhong-fu-de-dnaxu-lie-by-leetcode-soluti-z8zn/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。