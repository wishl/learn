package com.gmy.leetcode.dp;

/**
 * 假设你是一名博物馆管理员，你要把一个展厅分成若干个区域来展示不同的文物，
 * 每个区域的面积是确定的，但可以通过调整区域之间的分割线来改变每个区域的形状和大小。
 * 现在给定一个展厅，以及每个区域的面积和一个目标数量k，你需要将展厅划分为k个区域，并使得所有区域面积之和的最小值最大。
 * 请你设计一个动态规划算法，用于计算出该最大的最小值，并返回它。
 * 输入参数：
 * areas: 一个列表，表示每个区域的面积。
 * k: 目标区域数量。
 * 输出参数：
 * res: 整数，表示所有区域面积之和的最大值的最小值。
 * 示例：
 * 输入：areas = [1, 2, 3, 4, 5, 6, 7, 8, 9], k = 3
 * 输出：10
 * 解释：将展厅分成三个区域，每个区域的面积之和最大为10，可以将区域分割成[1,2,3,4]
 * [5,6,7] [8,9] 或者[1,2,3,4] [5,6] [7,8,9] 等等。
 *
 * 1,2,3,4,5 6,7 8,9
 *
 * 提示：
 * 1 <= k <= len(areas) <= 1000
 * 1 <= areas[i] <= 10^6
 *
 * 在这个问题中，我们需要将展厅划分为k个区域，并使得所有区域面积之和的最小值最大。
 * 也就是说，我们需要找到一种划分方案，使得这k个区域的面积之和最小，
 * 同时又要保证这个最小值要尽可能地大。因此，我们可以将这个问题转化为求解最小值的最大化问题。
 * 具体地，我们可以通过不断调整区域之间的分割线，使得每个区域的面积都尽可能的接近，
 * 从而达到最小化每个区域的面积之和的目的。同时，我们还要保证在最小化每个区域的面积之和的前提下，
 * 每个区域的面积都要大于等于0。最终，我们要找到一种划分方案，使得所有区域面积之和的最小值最大。
 */
public class TestDp {

    public void testDp(int[] nums) {

    }

}
